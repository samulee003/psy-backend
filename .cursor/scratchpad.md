# 心理治療預約系統 Bug 修復專案

## Background and Motivation

使用者 (治療師) 回報了一個嚴重錯誤：當他們從新的裝置或無痕模式登入系統時，無法看到原有的排班資訊。這導致他們無法有效管理自己的排班。此外，患者端也無法選擇治療師，顯示這可能是一個更廣泛的資料存取問題。根據瀏覽器開發者工具的截圖，API 請求 (例如 `/api/schedules/...`, `/api/appointments/my`) 回傳了 401 Unauthorized 錯誤，強烈暗示問題的根源在於身份驗證或授權機制。

此錯誤嚴重影響系統的核心功能，需要立即解決以確保治療師和患者都能正常使用系統。

近期，使用者進一步要求對系統進行全面性的 Bug 排查，以找出並修復其他潛在問題。

## Key Challenges and Analysis

1.  **身份驗證/授權 (Authentication/Authorization):**
    *   主要挑戰是找出為何後端在已驗證使用者於新會話/裝置上登入時回傳 401 錯誤。
    *   可能原因包括：
        *   會話管理問題 (例如，會話未正確持續，或在請求間未被正確識別)。
        *   基於權杖 (Token-based) 的身份驗證問題 (例如，權杖未被發送、權杖過早到期、權杖驗證失敗)。
        *   登入後使用者角色或權限檢查不正確。
    *   從截圖看，API `/api/schedules/2025/05?doctorId=4` 和 `/api/appointments/my` 都出現了 401 錯誤。這表示獲取排班和預約資訊的端點未能正確驗證使用者身份。

2.  **資料獲取邏輯 (Data Fetching Logic):**
    *   需要檢查負責獲取排班資料 (例如 `/api/schedules/...`, `/api/appointments/my`) 和治療師列表的 API 端點。
    *   確認這些端點在處理請求時，如何識別當前登入的使用者，並基於該使用者ID來查詢相關資料。

3.  **前端狀態管理 (Frontend State Management):**
    *   確保前端正確處理身份驗證狀態，並在所有受保護的 API 請求中附帶必要的憑證 (例如 JWT 權杖、會話 Cookie)。

4.  **問題重現性 (Reproducibility):**
    *   此問題可在無痕模式和不同裝置上重現，這有助於調試。

5. **全面性 Bug 排查的廣泛性**：
    * 需要系統性地檢閱代碼，對照常見 Bug 列表進行檢查，這可能涉及多個模組和功能。

## High-level Task Breakdown

**先前已完成的修復任務:**
1.  分析後端身份驗證日誌
2.  檢閱身份驗證中介軟體
3.  檢查獲取排班資料的 API 端點
4.  驗證前端的權杖/會話處理
5.  逐步偵錯跨裝置/無痕模式登入流程
6.  檢查資料庫使用者/角色資訊
7.  實施修復並重新測試 (針對跨裝置登入問題)
8.  檢查和修復患者端身份驗證問題
9.  修復：防止同一帳戶多次註冊 (完成)

**新的全面排查任務 (已完成排查，待總結):**
1.  **排查身份驗證相關潛在問題:**
    *   [x] 登出後緩存問題 (後端處理完成，依賴前端配合)
2.  **排查預約流程潛在問題:**
    *   [x] 重複預約同一時段 (低風險，可考慮增強資料庫約束)
    *   [x] 取消預約後狀態不一致 (功能增強建議，考慮 WebSocket 或通知)
    *   [x] 預約確認但發生衝突 (風險同「重複預約同一時段」，可考慮增強資料庫約束)
    *   [x] 用戶輸入資料未驗證 (需要改進，特別是日期和 patientInfo)
3.  **排查排班管理潛在問題:**
    *   [x] 排班重疊 (需要改進內部時間邏輯驗證和 defined_slots 與 start/end time 的一致性)
    *   [x] 過去時間仍可預約 (需要改進 createAppointment 和 getAvailableTimeSlots)
    *   [x] 重複刷新排班資料問題 (需要改進/功能增強建議，考慮批量接口和資料庫交易)
4.  **排查數據一致性潛在問題:**
    *   [x] 數據同步延遲 (功能增強建議，考慮即時通知/更新機制)
    *   [x] 統計資料不準確 (目前無此功能/未來需注意)
    *   [x] 刪除數據引起關聯問題 (風險較低，可改進 deleteUser 錯誤提示)
5.  **排查用戶界面潛在問題 (後端角度):**
    *   [x] 時區處理錯誤 (後端) (需要重大改進，明確時區策略並統一處理)
6.  **排查安全性潛在問題:**
    *   [x] 敏感資料暴露 (風險較低，持續關注權限和日誌)
    *   [x] SQL注入風險 (風險較低，已廣泛使用參數化查詢)
7.  **排查效能與可擴展性潛在問題:**
    *   [x] 歷史數據查詢緩慢 (需要改進，添加索引、解決N+1問題、實現分頁)

## Project Status Board

- [x] 分析後端身份驗證日誌 (完成)
- [x] 檢閱身份驗證中介軟體 (完成)
- [x] 檢查獲取排班資料的 API 端點 (完成)
- [x] 驗證前端的權杖/會話處理 (完成)
- [x] 逐步偵錯跨裝置/無痕模式登入流程 (完成)
- [x] 檢查資料庫使用者/角色資訊 (完成)
- [x] 實施修復並重新測試 (完成)
- [x] 檢查和修復患者端身份驗證問題 (完成)
- [x] 修復：防止同一帳戶多次註冊 (完成)
- [ ] **新的全面排查任務 (已完成排查，待總結)**
    - [x] 登出後緩存問題 (後端處理完成，依賴前端配合)
    - [x] 重複預約同一時段 (低風險，可考慮增強資料庫約束)
    - [x] 取消預約後狀態不一致 (功能增強建議，考慮 WebSocket 或通知)
    - [x] 預約確認但發生衝突 (風險同「重複預約同一時段」，可考慮增強資料庫約束)
    - [x] 用戶輸入資料未驗證 (需要改進，特別是日期和 patientInfo)
    - [x] 排班重疊 (需要改進內部時間邏輯驗證和 defined_slots 與 start/end time 的一致性)
    - [x] 過去時間仍可預約 (需要改進 createAppointment 和 getAvailableTimeSlots)
    - [x] 重複刷新排班資料問題 (需要改進/功能增強建議，考慮批量接口和資料庫交易)
    - [x] 數據同步延遲 (功能增強建議，考慮即時通知/更新機制)
    - [x] 統計資料不準確 (目前無此功能/未來需注意)
    - [x] 刪除數據引起關聯問題 (風險較低，可改進 deleteUser 錯誤提示)
    - [x] 時區處理錯誤 (後端) (需要重大改進，明確時區策略並統一處理)
    - [x] 敏感資料暴露 (風險較低，持續關注權限和日誌)
    - [x] SQL注入風險 (風險較低，已廣泛使用參數化查詢)
    - [x] 歷史數據查詢緩慢 (需要改進，添加索引、解決N+1問題、實現分頁)

- [ ] 為身份驗證和資料存取添加整合測試 (建議，未完成)

## Executor's Feedback or Assistance Requests

* **2024-05-18 (身份驗證日誌分析)**:
  * **發現**: 根據提供的日誌，問題清晰地指向 Cookie 身份驗證機制未能在登入後的後續請求中保持。
  * **關鍵觀察**:
    * 登入成功後，伺服器試圖設置 Cookie: `[Auth] 登入成功，設置 Cookie: 4 sasha0970@gmail.com doctor`
    * 但所有後續請求的 Cookie 是空的: `[Auth] Cookies: [Object: null prototype] {}`
    * 也沒有 Authorization 標頭: `[Auth] Authorization頭: undefined`
    * 結果: `[Auth] 未找到有效的身份令牌`
  * **問題定位**: Cookie 設置成功，但後續請求未能攜帶該 Cookie，可能的原因:
    1. Cookie 設置時未指定正確的屬性 (如 Domain, Path, SameSite 等)
    2. 在跨域環境中未正確配置 CORS 來允許 Cookie 傳遞
    3. 前端請求未設置 `credentials: 'include'` 來包含跨域 Cookie
    4. 瀏覽器安全策略 (如第三方 Cookie 限制) 阻止了 Cookie 的設置或傳遞
  * **下一步建議**: 檢查 `middlewares` 目錄中的身份驗證中介軟體，尤其是負責設置和驗證 Cookie 的部分

* **2024-05-19 (修復實施)**:
  * **問題根本原因**: 經過檢查代碼發現，關鍵問題在於：
    1. 伺服器嘗試僅通過 Cookie 來存儲和傳遞身份驗證令牌
    2. 但由於跨域、無痕模式或瀏覽器安全策略，Cookie 未能在後續請求中被正確傳遞
    3. 後端沒有提供足夠的身份驗證替代方案來處理 Cookie 傳遞失敗的情況
  
  * **實施的修復**:
    1. **增強身份驗證中介軟體**:
       - 修改 `auth.js` 以支持從多種來源獲取 token：Cookie、Authorization 頭和 URL 參數
       - 這樣即使一種身份驗證方式失敗，系統仍有替代方案可用
    
    2. **改進登入 API 回應**:
       - 修改 `authController.js` 中的 login 函數，使其在回應中返回 token
       - 這使得前端可以將 token 存儲在 localStorage 中，作為 Cookie 的備用方案
    
    3. **優化 CORS 配置**:
       - 在 `app.js` 中更新 CORS 設置，添加更多允許的來源和方法
       - 確保正確設置 `credentials: true` 和必要的請求頭
    
    4. **提供前端實施指南**:
       - 創建 `README.md` 文件，詳細說明前端需要做的調整
       - 提供代碼示例，說明如何正確實施 token 存儲和請求攔截器
  
  * **預期結果**:
    - 使用者現在應該能夠在不同裝置和無痕模式下正常登入和使用系統
    - 前端將從登入響應中獲取 token 並存儲在 localStorage 中
    - 所有 API 請求將嘗試從 Cookie 和 localStorage 獲取 token，並通過 Authorization 頭發送
    - 這樣即使 Cookie 失敗，系統仍能通過 Authorization 頭進行身份驗證

* **2024-05-19 (患者端修復)**:
  * **檢查結果**: 經過檢查患者端相關代碼發現：
    1. 患者端與醫生端共用相同的身份驗證機制，使用了相同的中介軟體
    2. 患者能夠查看排班信息、預約醫生，這些API端點都受到了身份驗證的保護
    3. 患者只能修改自己的預約，代碼中有適當的權限檢查
  
  * **實施的修復**:
    1. **改進註冊 API 回應**:
       - 修改 `authController.js` 中的 register 函數，使其在回應中返回 token
       - 添加正確的 Cookie 設置選項 (sameSite, path)
    
    2. **更新 README 文件**:
       - 添加關於患者端身份驗證修復的說明
       - 提供患者端前端實施所需的代碼示例，包括註冊後的 token 存儲
  
  * **預期結果**:
    - 患者用戶現在應該能夠在不同裝置和無痕模式下正常註冊、登入和使用系統
    - 患者可以查看醫生排班信息並創建預約
    - 身份驗證將在各種環境下正常工作，不再出現 401 錯誤

* **2024-05-20 (重複註冊修復)**:
  * **檢查結果**: 發現註冊時僅檢查 email 是否重複，未檢查 username。
  * **實施的修復**: 修改 `authController.js` 中的 `register` 函數，使其在檢查用戶是否存在時，同時檢查 `email` 和 `username` 欄位。
  * **預期結果**: 防止使用相同 `email` 或 `username` 的用戶重複註冊。

## Lessons

*   在程式輸出中包含有助於偵錯的資訊。
*   在嘗試編輯檔案之前先閱讀它。
*   如果終端機中出現漏洞，請在繼續操作前執行 `npm audit`。
*   在使用 `-force` git 指令前務必詢問。
*   新的裝置/無痕模式下出現 401 錯誤，通常指向會話持續性、權杖處理或初始登入後如何為後續 API 呼叫建立使用者身份的問題。
*   跨域環境中的 Cookie 身份驗證需要特別注意 Cookie 屬性設置和 CORS 配置，否則容易導致身份驗證失敗。
*   身份驗證系統應該提供多種身份驗證方式作為備用，避免單點故障。比如同時支持 Cookie 和 Authorization 頭中的令牌。
*   前端應用應該實施請求攔截器，確保所有 API 請求都帶有正確的身份驗證信息。
*   在跨域環境中工作時，fetch 請求需要設置 `credentials: 'include'` 才能傳遞 Cookie。
*   登入和註冊功能應該採用一致的方式處理身份驗證，確保用戶體驗一致，避免一個功能工作而另一個功能失敗的情況。
*   檢查用戶是否存在時，應考慮所有可用作唯一識別碼的欄位 (例如，email 和 username)。 